# 実装ガイドライン

このドキュメントでは、開発プロセスに沿った具体的な実装手順と、コード品質を確保するためのベストプラクティスについて詳述します。現在はプロジェクト初期段階であり、ガイドラインは開発の進行に伴って精緻化されていきます。

## 1. 実装の基本原則

### 1.1 コード品質の確保

- **可読性**: 他の開発者が容易に理解できるコードを書く
- **保守性**: 将来の変更や拡張が容易な設計を心がける
- **テスト容易性**: ユニットテストが書きやすいコード構造を目指す
- **パフォーマンス**: 効率的なアルゴリズムとデータ構造を選択する
- **セキュリティ**: セキュリティリスクを最小化する実装を行う

### 1.2 命名規則

- **ファイル名**:

  - コンポーネント: PascalCase (`Button.tsx`, `ChatMessage.tsx`)
  - ユーティリティ/フック: camelCase (`useAuth.ts`, `formatDate.ts`)
  - ページ: page.tsx (Next.js App Router 規約に従う)

- **変数名**:

  - 一般変数: camelCase (`userName`, `messageList`)
  - 定数: UPPER_CASE (`MAX_MESSAGES`, `API_ENDPOINT`)
  - 型/インターフェース: PascalCase (`User`, `Message`)

- **コンポーネント**:
  - UI (Presentation) コンポーネント: `<Name>`形式 (`ChatMessage`, `UserAvatar`)
  - Container コンポーネント: `<Name>Container`形式 (`ChatContainer`, `MessageListContainer`)

## 2. 段階的実装フロー

### 2.1 コンポーネント実装フロー

1. **仕様確認**:

   - 機能仕様書を熟読し、要件を完全に理解する
   - 不明点はその場で質問し、認識の齟齬を早期に解消する

2. **テストケース設計**:

   - 正常系・異常系の両方のテストケースを設計
   - エッジケースも含めた網羅的なテストシナリオを検討

3. **テストコード作成**:

   - TDD アプローチに基づき、テストコードを先に作成
   - テストが「失敗」することを確認する

4. **コンポーネント実装**:

   - テストに合格するコードを実装
   - 必要最小限の機能から始め、段階的に拡張する

5. **リファクタリング**:

   - コードの品質向上と重複排除のためのリファクタリング
   - テストが引き続き合格することを確認

6. **レビュー**:
   - コードレビューを通じて品質とベストプラクティスを確保
   - フィードバックを取り入れて改善

### 2.2 API 実装フロー (検討中)

1. **インターフェース定義**:

   - API のエンドポイント、メソッド、パラメータ、レスポンスを定義
   - OpenAPI/Swagger 形式でドキュメント化

2. **モックの作成**:

   - フロントエンド開発のためのモックデータの作成
   - MSW (Mock Service Worker) を使用したモックサーバーの構築

3. **API テスト作成**:

   - API の入出力と動作を検証するテストの作成
   - 異常系のテストケースも含める

4. **API 実装**:

   - Supabase の機能を活用した効率的な実装
   - セキュリティを考慮した実装（認証、承認、入力検証等）

5. **パフォーマンス最適化**:
   - クエリの最適化
   - キャッシュ戦略の実装
   - レスポンスタイムの測定と改善

## 3. コーディングスタイル (検討中)

### 3.1 TypeScript のベストプラクティス

- **厳格な型付け**:

  - `any` 型の使用を最小限に抑える
  - 可能な限り明示的な型を指定する
  - `unknown` 型と型ガードを活用する

- **型の集約管理**:

  - 共通の型を集約して管理する
  - 関連する型は同じファイルで定義する
  - 型の再利用性を高める

- **型の安全性向上**:
  - Zod などのバリデーションライブラリを活用
  - API レスポンスの型安全性を確保
  - ユーザー入力の型検証を徹底

### 3.2 React のベストプラクティス

- **コンポーネントの分割**:

  - 単一責任の原則に従ったコンポーネント設計
  - 適切な粒度でのコンポーネント分割
  - ロジックとプレゼンテーションの分離

- **パフォーマンスの最適化**:

  - メモ化（`useMemo`, `useCallback`, `memo`）の適切な使用
  - レンダリング最適化のテクニック活用
  - 不要な再レンダリングの防止

- **カスタムフックの活用**:
  - ロジックを再利用可能なカスタムフックに抽出
  - 複雑なステート管理や副作用を封装
  - テスト可能性を高めるための設計

### 3.3 Next.js App Router のベストプラクティス

- **サーバーコンポーネントとクライアントコンポーネントの使い分け**:

  - デフォルトでサーバーコンポーネントを使用
  - インタラクティブ性が必要な場合のみクライアントコンポーネントを使用
  - "use client" ディレクティブを適切に配置

- **ルートレイアウトの効果的な使用**:

  - 共通レイアウト要素の配置
  - ネストされたレイアウトの活用
  - グローバル状態の適切な配置

- **データフェッチングの最適化**:
  - `fetch` API の使用とキャッシュ戦略の活用
  - Suspense を用いた UX の向上
  - ストリーミングレスポンスの活用

## 4. エラーハンドリング (検討中)

### 4.1 クライアントサイドのエラーハンドリング

- **ユーザーフレンドリーなエラーメッセージ**:

  - 技術的な詳細を隠した、ユーザーが理解しやすいメッセージ
  - アクション可能な解決策の提示

- **グローバルエラーハンドリング**:

  - 予期せぬエラーをキャッチするグローバルエラーハンドラー
  - エラーバウンダリによる UI の安定性確保

- **段階的なフォールバック**:
  - エラー発生時のフォールバック UI の提供
  - データ取得エラー時の過去のキャッシュデータの使用

### 4.2 サーバーサイドのエラーハンドリング

- **構造化されたエラーレスポンス**:

  - 一貫した形式のエラーレスポンス
  - ステータスコードの適切な使用

- **ログ記録**:

  - エラーの詳細な記録
  - デバッグに必要な情報の提供

- **リトライ機構**:
  - 一時的なエラーに対するリトライロジック
  - 指数バックオフアルゴリズムの使用

## 5. 状態管理 (検討中)

### 5.1 ローカル状態管理

- **React 標準フック**:

  - `useState` によるコンポーネントローカル状態
  - `useReducer` による複雑な状態ロジック

- **コンテキスト API**:
  - 深いネストを避けるためのコンテキスト活用
  - パフォーマンスを考慮した設計

### 5.2 グローバル状態管理

- **サーバー状態と UI 状態の分離**:

  - React Query / SWR によるサーバー状態管理
  - 必要に応じて Context / Redux / Zustand によるクライアント状態管理

- **適切な状態の配置**:
  - 最も近い共通祖先でのローカル状態管理
  - グローバル状態の最小化

## 6. パフォーマンス最適化 (検討中)

### 6.1 初期ロードの最適化

- **コード分割**:

  - ダイナミックインポートによる遅延ロード
  - ルートベースの自動コード分割

- **画像最適化**:

  - Next.js の Image コンポーネントの活用
  - 適切なフォーマットと圧縮の使用

- **フォントの最適化**:
  - Next.js のフォント最適化機能の活用
  - Web フォントの効率的なロード

### 6.2 レンダリングの最適化

- **不要な再レンダリングの防止**:

  - メモ化テクニックの適切な使用
  - 大きなリストの仮想化

- **レンダリングスケジュール**:
  - 優先度の低いレンダリングの遅延
  - ユーザー操作に対するレスポンスの優先

## 7. プロジェクト設定ベストプラクティス (予定)

### 7.1 コード品質ツール

- **ESLint**:

  - プロジェクト固有のルールセット
  - 自動フォーマットとの連携

- **Prettier**:

  - 一貫したコードフォーマット
  - エディタ連携による保存時フォーマット

- **TypeScript の厳格モード**:
  - `strict: true` の設定
  - 追加の厳格チェックの有効化

### 7.2 テスト環境

- **Jest + React Testing Library**:

  - コンポーネントとフックのテスト
  - スナップショットテスト

- **Cypress**:

  - E2E テストの自動化
  - ビジュアルリグレッションテスト

- **Storybook**:
  - コンポーネントの視覚的テスト
  - インタラクションテスト

## 8. セキュリティベストプラクティス (予定)

- **認証と認可**:

  - Supabase 認証の適切な実装
  - RLS (Row Level Security) の活用

- **OWASP ガイドラインの遵守**:

  - インジェクション攻撃の防止
  - XSS 対策の実装

- **機密情報の管理**:
  - 環境変数の適切な使用
  - クライアントサイドでの機密情報非露出

## 実装ステップ

1. **初期設定フェーズ** (現在)

   - ESLint, Prettier, TypeScript の設定
   - ディレクトリ構造の確立
   - 基本的なコンポーネント規約の策定

2. **基本コンポーネント開発フェーズ**

   - 汎用 UI コンポーネントの実装
   - Storybook でのカタログ化
   - ユニットテストの作成

3. **機能開発フェーズ**
   - 各機能の段階的実装
   - テスト駆動開発の実践
   - コードレビューによる品質確保

## 次のステップ

- プロジェクトの初期設定の確立
- ESLint と Prettier の設定
- TypeScript の設定とベストプラクティスの確立
- 基本的なディレクトリ構造の作成
