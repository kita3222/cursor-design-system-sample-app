# 実装ガイドライン

このドキュメントでは、開発プロセスに沿った具体的な実装手順と、コード品質を確保するためのベストプラクティスについて詳述します。現在はプロジェクト初期段階であり、ガイドラインは開発の進行に伴って精緻化されていきます。

## 1. 実装の基本原則

### 1.1 コード品質の確保

- **可読性**: 他の開発者が容易に理解できるコードを書く
- **保守性**: 将来の変更や拡張が容易な設計を心がける
- **テスト容易性**: ユニットテストが書きやすいコード構造を目指す
- **パフォーマンス**: 効率的なアルゴリズムとデータ構造を選択する
- **セキュリティ**: セキュリティリスクを最小化する実装を行う

### 1.2 命名規則

- **ファイル名**:

  - コンポーネント: PascalCase (`Button.tsx`, `ChatMessage.tsx`)
  - ユーティリティ/フック: camelCase (`useAuth.ts`, `formatDate.ts`)
  - ページ: page.tsx (Next.js App Router 規約に従う)
  - ストーリーファイル: `<コンポーネント名>.stories.tsx` (Storybook規約に従う)

- **変数名**:

  - 一般変数: camelCase (`userName`, `messageList`)
  - 定数: UPPER_CASE (`MAX_MESSAGES`, `API_ENDPOINT`)
  - 型/インターフェース: PascalCase (`User`, `Message`)

- **コンポーネント**:
  - UI (Presentation) コンポーネント: `<n>`形式 (`ChatMessage`, `UserAvatar`)
  - Container コンポーネント: `<n>Container`形式 (`ChatContainer`, `MessageListContainer`)

### 1.3 コンポーネント開発ルール

- **Storybook対応**:

  - `app/_components`に定義するすべてのコンポーネントは、Storybookストーリーファイルを作成すること
  - ストーリーファイルは同じディレクトリに`<コンポーネント名>.stories.tsx`として配置
  - コンポーネントの各バリエーションや状態を網羅するストーリーを作成
  - コンポーネントのプロパティとその使用方法をドキュメント化
  - 実装完了前にStorybookで視覚的に確認し、UI一貫性とアクセシビリティを検証

- **コンポーネント構造**:
  - 単一責任の原則に従い、1つのコンポーネントに1つの責任を持たせる
  - props型定義を明示的に行い、必須プロパティと任意プロパティを区別
  - デフォルト値を適切に設定し、使いやすさを考慮

## 2. 段階的実装フロー

### 2.1 コンポーネント実装フロー

1. **仕様確認**:

   - 機能仕様書を熟読し、要件を完全に理解する
   - 不明点はその場で質問し、認識の齟齬を早期に解消する

2. **テストケース設計**:

   - 正常系・異常系の両方のテストケースを設計
   - エッジケースも含めた網羅的なテストシナリオを検討

3. **テストコード作成**:

   - TDD アプローチに基づき、テストコードを先に作成
   - テストが「失敗」することを確認する

4. **コンポーネント実装**:

   - テストに合格するコードを実装
   - 必要最小限の機能から始め、段階的に拡張する

5. **Storybookでの文書化と視覚化**:

   - 実装したコンポーネントをStorybookに登録
   - 各バリエーションとユースケースをStoryとして定義
   - コンポーネントの使用方法をMDXで文書化

6. **Storybookを通じたレビュー**:

   - Storybookを使用したビジュアルレビュー
   - 各バリエーションの動作確認
   - フィードバックに基づく修正
   - 修正後の再レビュー
   - 承認されるまでこのサイクルを繰り返す

7. **リファクタリング**:

   - コードの品質向上と重複排除のためのリファクタリング
   - テストが引き続き合格することを確認

8. **最終レビュー**:
   - コードレビューを通じて品質とベストプラクティスを確保
   - フィードバックを取り入れて改善
   - 承認された内容を統合

### 2.2 API 実装フロー (検討中)

1. **インターフェース定義**:

   - API のエンドポイント、メソッド、パラメータ、レスポンスを定義
   - OpenAPI/Swagger 形式でドキュメント化

2. **モックの作成**:

   - フロントエンド開発のためのモックデータの作成
   - MSW (Mock Service Worker) を使用したモックサーバーの構築

3. **API テスト作成**:

   - API の入出力と動作を検証するテストの作成
   - 異常系のテストケースも含める

4. **API 実装**:

   - Supabase の機能を活用した効率的な実装
   - セキュリティを考慮した実装（認証、承認、入力検証等）

5. **パフォーマンス最適化**:
   - クエリの最適化
   - キャッシュ戦略の実装
   - レスポンスタイムの測定と改善

## 3. Storybookを用いたコンポーネント開発プロセス

### 3.1 Storybook活用の原則

- **コンポーネント開発の中心ツールとしてStorybookを位置付ける**
- **コンポーネント実装後は必ずStorybookでの登録と文書化を行う**
- **Storybookを通じたレビューと承認を経てからコンポーネントを本実装に統合する**
- **コンポーネントの変更・拡張時も同様のプロセスでStorybookを更新する**

### 3.2 Storyの実装ガイドライン

#### Story実装の基本構造

```tsx
// Componentname.stories.tsx
import type { Meta, StoryObj } from "@storybook/react";
import { ComponentName } from "./ComponentName";

const meta: Meta<typeof ComponentName> = {
  title: "カテゴリ/ComponentName",
  component: ComponentName,
  parameters: {
    layout: "centered",
  },
  tags: ["autodocs"],
  argTypes: {
    // コンポーネントのpropsに対するコントロール定義
    variant: {
      control: "select",
      options: ["primary", "secondary", "outline"],
      description: "コンポーネントのバリエーション",
    },
    // 他のpropsに対する定義
  },
};

export default meta;
type Story = StoryObj<typeof ComponentName>;

// 基本的なストーリー（必須）
export const Default: Story = {
  args: {
    // デフォルト値
  },
};

// バリエーション別のストーリー
export const Primary: Story = {
  args: {
    variant: "primary",
    // その他の値
  },
};

export const Secondary: Story = {
  args: {
    variant: "secondary",
    // その他の値
  },
};

// 状態別のストーリー
export const Disabled: Story = {
  args: {
    ...Default.args,
    disabled: true,
  },
};

// 特殊なケースを示すストーリー
export const WithLongText: Story = {
  args: {
    ...Default.args,
    children: "非常に長いテキストを含む場合の表示確認",
  },
};
```

#### MDX文書化ガイドライン

````mdx
{/* ComponentName.mdx */}
import { Meta, Story, Canvas, ArgsTable } from '@storybook/blocks';
import { ComponentName } from './ComponentName';
import \* as ComponentStories from './ComponentName.stories';

<Meta of={ComponentStories} />

# コンポーネント名

コンポーネントの概要説明。目的、主な使用場面、特徴を簡潔に記述します。

## 基本的な使い方

<Canvas of={ComponentStories.Default} />

## バリエーション

コンポーネントの各バリエーションと、使い分けのガイドラインを示します。

<Canvas of={ComponentStories.Primary} />
<Canvas of={ComponentStories.Secondary} />

## 状態

コンポーネントの異なる状態（無効、エラー、ロード中など）を示します。

<Canvas of={ComponentStories.Disabled} />

## 実装例

```tsx
import { ComponentName } from "@/components/ui/ComponentName";

function ExampleUse() {
  return (
    <ComponentName variant="primary" onClick={() => console.log("クリック")}>
      テキスト
    </ComponentName>
  );
}
```
````

## Props

<ArgsTable of={ComponentName} />

## アクセシビリティ

アクセシビリティに関する注意点や対応について記述します。

## 注意事項

コンポーネント使用時の注意点、既知の制限、パフォーマンスに関する考慮点などを記述します。

```

### 3.3 レビュープロセス

Storybookを通じたコンポーネントレビューは以下の手順で実施されます：

1. **実装者によるStorybook登録**
   - コンポーネント実装後、すべてのバリエーションをStoryとして登録
   - MDXドキュメントで使用方法を文書化
   - `npm run storybook`でローカル環境での動作確認

2. **レビュー依頼**
   - レビュー依頼時にStorybookへのリンクを共有
   - レビュー範囲と確認ポイントを明記

3. **レビュアーによる確認**
   - 視覚的一貫性（デザインシステムとの整合性）
   - 機能的正確性（各状態、イベントハンドリング）
   - レスポンシブ対応
   - アクセシビリティ
   - ドキュメントの完全性

4. **フィードバックと修正サイクル**
   - レビュアーからのフィードバックを収集
   - 優先度に応じた修正の実施
   - Storybook更新による修正結果の共有
   - 必要に応じてサイクルを繰り返す

5. **最終承認**
   - すべての修正が完了し、レビュアーの承認を得た後に統合

### 3.4 Storybookレビュー基準

以下の観点からコンポーネントをレビューします：

1. **デザインシステムとの整合性**
   - カラーパレット、タイポグラフィ、スペーシングの正確な適用
   - デザイントークンの適切な使用
   - 視覚的な一貫性

2. **機能要件の充足**
   - 仕様書で定義された全機能の実装
   - 各状態（normal, hover, focus, active, disabled）の正確な表現
   - エラー状態の適切な表示

3. **レスポンシブ対応**
   - 各ブレークポイントでの適切な表示
   - モバイルでの使いやすさ
   - タッチ操作への対応

4. **アクセシビリティ**
   - キーボードナビゲーション
   - スクリーンリーダー対応
   - コントラスト比
   - WAI-ARIA属性の適切な使用

5. **使用性と拡張性**
   - APIの使いやすさと一貫性
   - 拡張が容易な設計
   - エッジケースへの対応

## 4. コーディングスタイル (検討中)

### 4.1 TypeScript のベストプラクティス

- **厳格な型付け**:

  - `any` 型の使用を最小限に抑える
  - 可能な限り明示的な型を指定する
  - `unknown` 型と型ガードを活用する

- **型の集約管理**:

  - 共通の型を集約して管理する
  - 関連する型は同じファイルで定義する
  - 型の再利用性を高める

- **型の安全性向上**:
  - Zod などのバリデーションライブラリを活用
  - API レスポンスの型安全性を確保
  - ユーザー入力の型検証を徹底

### 4.2 React のベストプラクティス

- **コンポーネントの分割**:

  - 単一責任の原則に従ったコンポーネント設計
  - 適切な粒度でのコンポーネント分割
  - ロジックとプレゼンテーションの分離

- **パフォーマンスの最適化**:

  - メモ化（`useMemo`, `useCallback`, `memo`）の適切な使用
  - レンダリング最適化のテクニック活用
  - 不要な再レンダリングの防止

- **カスタムフックの活用**:
  - ロジックを再利用可能なカスタムフックに抽出
  - 複雑なステート管理や副作用を封装
  - テスト可能性を高めるための設計

### 4.3 Next.js App Router のベストプラクティス

- **サーバーコンポーネントとクライアントコンポーネントの使い分け**:

  - デフォルトでサーバーコンポーネントを使用
  - インタラクティブ性が必要な場合のみクライアントコンポーネントを使用
  - "use client" ディレクティブを適切に配置

- **ルートレイアウトの効果的な使用**:

  - 共通レイアウト要素の配置
  - ネストされたレイアウトの活用
  - グローバル状態の適切な配置

- **データフェッチングの最適化**:
  - `fetch` API の使用とキャッシュ戦略の活用
  - Suspense を用いた UX の向上
  - ストリーミングレスポンスの活用

## 5. エラーハンドリング (検討中)

### 5.1 クライアントサイドのエラーハンドリング

- **ユーザーフレンドリーなエラーメッセージ**:

  - 技術的な詳細を隠した、ユーザーが理解しやすいメッセージ
  - アクション可能な解決策の提示

- **グローバルエラーハンドリング**:

  - 予期せぬエラーをキャッチするグローバルエラーハンドラー
  - エラーバウンダリによる UI の安定性確保

- **段階的なフォールバック**:
  - エラー発生時のフォールバック UI の提供
  - データ取得エラー時の過去のキャッシュデータの使用

### 5.2 サーバーサイドのエラーハンドリング

- **構造化されたエラーレスポンス**:

  - 一貫した形式のエラーレスポンス
  - ステータスコードの適切な使用

- **ログ記録**:

  - エラーの詳細な記録
  - デバッグに必要な情報の提供

- **リトライ機構**:
  - 一時的なエラーに対するリトライロジック
  - 指数バックオフアルゴリズムの使用

## 6. 状態管理 (検討中)

### 6.1 ローカル状態管理

- **React 標準フック**:

  - `useState` によるコンポーネントローカル状態
  - `useReducer` による複雑な状態ロジック

- **コンテキスト API**:
  - 深いネストを避けるためのコンテキスト活用
  - パフォーマンスを考慮した設計

### 6.2 グローバル状態管理

- **サーバー状態と UI 状態の分離**:

  - React Query / SWR によるサーバー状態管理
  - 必要に応じて Context / Redux / Zustand によるクライアント状態管理

- **適切な状態の配置**:
  - 最も近い共通祖先でのローカル状態管理
  - グローバル状態の最小化

## 7. パフォーマンス最適化 (検討中)

### 7.1 初期ロードの最適化

- **コード分割**:

  - ダイナミックインポートによる遅延ロード
  - ルートベースの自動コード分割

- **画像最適化**:

  - Next.js の Image コンポーネントの活用
  - 適切なフォーマットと圧縮の使用

- **フォントの最適化**:
  - Next.js のフォント最適化機能の活用
  - Web フォントの効率的なロード

### 7.2 レンダリングの最適化

- **不要な再レンダリングの防止**:

  - メモ化テクニックの適切な使用
  - 大きなリストの仮想化

- **レンダリングスケジュール**:
  - 優先度の低いレンダリングの遅延
  - ユーザー操作に対するレスポンスの優先

## 8. プロジェクト設定ベストプラクティス (予定)

### 8.1 コード品質ツール

- **ESLint**:

  - プロジェクト固有のルールセット
  - 自動フォーマットとの連携

- **Prettier**:

  - 一貫したコードフォーマット
  - エディタ連携による保存時フォーマット

- **TypeScript の厳格モード**:
  - `strict: true` の設定
  - 追加の厳格チェックの有効化

### 8.2 テスト環境

- **Jest + React Testing Library**:

  - コンポーネントとフックのテスト
  - スナップショットテスト

- **Cypress**:

  - E2E テストの自動化
  - ビジュアルリグレッションテスト

- **Storybook**:
  - コンポーネントの視覚的テスト
  - インタラクションテスト

## 9. セキュリティベストプラクティス (予定)

- **認証と認可**:

  - Supabase 認証の適切な実装
  - RLS (Row Level Security) の活用

- **OWASP ガイドラインの遵守**:

  - インジェクション攻撃の防止
  - XSS 対策の実装

- **機密情報の管理**:
  - 環境変数の適切な使用
  - クライアントサイドでの機密情報非露出

## 実装ステップ

1. **初期設定フェーズ** (現在)

   - ESLint, Prettier, TypeScript の設定
   - ディレクトリ構造の確立
   - 基本的なコンポーネント規約の策定

2. **基本コンポーネント開発フェーズ**

   - 汎用 UI コンポーネントの実装
   - Storybook でのカタログ化
   - ユニットテストの作成

3. **機能開発フェーズ**
   - 各機能の段階的実装
   - テスト駆動開発の実践
   - コードレビューによる品質確保

## 次のステップ

- プロジェクトの初期設定の確立
- ESLint と Prettier の設定
- TypeScript の設定とベストプラクティスの確立
- 基本的なディレクトリ構造の作成
```
